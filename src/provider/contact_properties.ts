import * as pulumi from "@pulumi/pulumi";
import { HubSpotClient } from "./hubspot_client";
import { getResourceDiffKeys, ObjectCheckFailureValidator } from "./utils";
import { ContactPropertyProps, ContactPropertyApiArgs } from "../../types/ContactProperty";

type ValidatorMethodKey = "string" | "number" | "boolean" | "array";
type ValidatorMethod = "isString" | "isNumber" | "isBoolean" | "isArray";

interface ValidatorMethodMap {
    [key: string]: ValidatorMethod;
}

class ContactPropertyProvider implements pulumi.dynamic.ResourceProvider {
    // REST API object for communicating with the HubSpot API.
    private hsClient: HubSpotClient;

    // An object for mapping a type to is validator function.
    private validatorMethodMap: ValidatorMethodMap = {
        "string": "isString",
        "number": "isNumber",
        "boolean": "isBoolean",
        "array": "isArray",
    };

    constructor() {
        this.hsClient = new HubSpotClient();
    }

    /**
     * Return an object of contact property types. This is used for field validation.
     */
    private typeValues() {
        return {
            autoGeneratedViaImport: "boolean",
            name: "string",
            label: "string",
            groupName: "string",
            type: "string",
            fieldType: "string",
            description: "string",
            formField: "boolean",
            displayOrder: "number",
            mutableDefinitionNotDeletable: "boolean",
            readOnly: "boolean",
            readOnlyDefinition: "boolean",
            hidden: "boolean",
            options: "array",
            deleted: "boolean",
            calculated: "boolean",
            externalOptions: "boolean",
        };
    }

    /**
     * This function populates a ContactPropertyApiArgs object with
     * default values for optional fields.
     *
     * @param args An object containing contact property API values.
     */
    private populateDefaultValues(args: ContactPropertyApiArgs): ContactPropertyApiArgs {
        const defaults = {
            description: args.name,
            formField: false,
            displayOrder: -1,
            mutableDefinitionNotDeletable: false,
            readOnly: false,
            readOnlyDefinition: false,
            hidden: false,
            options: [],
            deleted: false,
            calculated: false,
        };

        // If the description is empty set it to the name of the field.
        if (args.description === "") {
            args.description = args.name;
        }

        return Object.assign({}, defaults, args);
    }

    /**
     * This function checks that a potential update to the state of a contact property
     * contains valid values.
     *
     * @param update An object containing contact property API values.
     */
    private validateUpdateObject(update: ContactPropertyApiArgs): pulumi.dynamic.CheckFailure[] {
        // These are required fields that are not autopopulated. If these fields are not present
        // the HubSpot API will throw an error.
        const requiredFields = [ "name", "label", "groupName", "type", "fieldType" ];

        // Populate the update object with default values.
        const updateWithDefaults = this.populateDefaultValues(update);

        // Create a new validator object.
        const validator = new ObjectCheckFailureValidator(updateWithDefaults);

        // Create a map of fields to their types.
        const typeValues: any = this.typeValues();

        // Create an array of keys to check.
        const updateKeys = Object.keys(updateWithDefaults).filter((key: string) => {
            // Do not validate the __provider field.
            if (key === "__provider") {
                return false;
            }

            // Filter out required field as we will concat them in the next function in the chain.
            return requiredFields.indexOf(key) === -1;
        }).concat(requiredFields);

        // For every update key validate the value.
        for (let i = 0; i < updateKeys.length; i++) {
            const key = updateKeys[i];

            // Get the type of the field.
            const valueType: ValidatorMethodKey = typeValues[key];

            // Get the validator method for the field's type.
            const validatorMethod: ValidatorMethod = this.validatorMethodMap[valueType];

            // Validate the value.
            validator.key(key).isPresent()[validatorMethod]();
        }

        // Return any failures.
        return validator.getFailures();
    }

    /**
     * This function validates the values of an update request and returns any failures
     * with the update inputs.
     *
     * @param old An object containing contact property API values of the current state.
     * @param update An object containing contact property API values of the proposed changes.
     */
    public async check(old: ContactPropertyProps, update: ContactPropertyApiArgs): Promise<pulumi.dynamic.CheckResult> {
        const failures = this.validateUpdateObject(update);
        return { failures, inputs: update };
    }

    public async diff(id: pulumi.ID, old: ContactPropertyProps, update: ContactPropertyApiArgs): Promise<pulumi.dynamic.DiffResult> {
        const replaces = getResourceDiffKeys(old, update);
        return { replaces };
    }

    private managementOnlyField(args: ContactPropertyApiArgs): boolean {
        return args.autoGeneratedViaImport === true;
    }

    public async create(args: ContactPropertyApiArgs): Promise<pulumi.dynamic.CreateResult> {
        const apiArgs = this.populateDefaultValues(args);
        const shouldNotActuallyCreate = this.managementOnlyField(args);

        if (shouldNotActuallyCreate) {
            return {
                id: args.name,
                outs: { createdContactProperty: args },
            }
        }

        const [ err, createdContactProperty ] = await this.hsClient.post("/properties/v1/contacts/properties", apiArgs);
        if (err) {
            const propertyExists = err?.response?.data?.propertiesErrorCode === "PROPERTY_EXISTS";
            if (propertyExists) {
                const getURL = "/properties/v1/contacts/properties/named/" + apiArgs.name;
                const [ err, existingContactProperty ] = await this.hsClient.get(getURL);
                if (err || !existingContactProperty) {
                    throw new Error(`Error reading contact property [${apiArgs.name}]`);
                }

                const checkValues = [ existingContactProperty.calculated, existingContactProperty.readOnly ];

                if (checkValues.indexOf(true) > -1) {
                    await pulumi.log.info(`Contacty property [${apiArgs.name}] cannot be changed because it is calculated. This property will only be managed by Pulumi.`, undefined, undefined, true);
                    return {
                        id: existingContactProperty?.name,
                        outs: { createdContactProperty: existingContactProperty },
                    };
                }

                const { outs } = await this.update(existingContactProperty?.id, existingContactProperty, apiArgs)

                return {
                    id: existingContactProperty?.name,
                    outs: outs,
                };
            }
            throw new Error(`Contact Property Creation failed [${apiArgs.name}]: ${err?.response?.data?.message}`)
        }

        return {
            id: createdContactProperty?.name,
            outs: { createdContactProperty },
        };
    }

    public async update(id: string, out: any, update: ContactPropertyApiArgs): Promise<pulumi.dynamic.UpdateResult> {
        const fieldUpdates = Object.assign({}, out, update);
        const apiArgs = this.populateDefaultValues(fieldUpdates);

        // Throw an error if the API name is changed as this could lead to something breaking.
        // TODO: Find a way to safely change an API name.
        if (apiArgs.name !== out.name) {
            throw new Error(`Cannot change API name of contact property. This may cause a workflow to break. [${apiArgs.name}]`);
        }

        const url = "/properties/v1/contacts/properties/named/" + apiArgs.name;
        const [ err, updates ] = await this.hsClient.put(url, apiArgs);
        if (err) {
            throw new Error("There was an error updating the contact property: " + err);
        }

        return {
            outs: { createdContactProperty: updates, isUpdate: true },
        };
    }

    public async read(id: string, props: { createdContactProperty: ContactPropertyApiArgs }): Promise<pulumi.dynamic.ReadResult> {
        const url = "/properties/v1/contacts/properties/named/" + props.createdContactProperty.name;
        const [ err, contactProperty ] = await this.hsClient.get(url);
        if (err || !contactProperty) {
            throw new Error(`Error reading contact property [${props.createdContactProperty.name}]`);
        }

        return {
            id: props.createdContactProperty.name,
            props: Object.assign({}, props, { createdContactPropery: contactProperty }),
        };
    }

    public async delete(id: string, props: { createdContactProperty: ContactPropertyApiArgs, isUpdate?: boolean }): Promise<void> {
        if (props.isUpdate) {
            return;
        }

        const apiArgs = this.populateDefaultValues(props.createdContactProperty);
        const shouldNotActuallyDelete = this.managementOnlyField(apiArgs);

        if (shouldNotActuallyDelete) {
            await pulumi.log.info(`The Property '${apiArgs.name}' cannot be deleted. Removing from Pulumi management.`);
            return;
        }

        const url = "/properties/v1/contacts/properties/named/" + apiArgs.name;
        const [ err, contactPropery ] = await this.hsClient.delete(url, {});
        if (err) {
            throw new Error(`Error deleting contact property [${apiArgs.name}]: ${err?.response?.data?.message}`);
        }

        await pulumi.log.info(`Contact property [${apiArgs.name}] deleted successfully.`, undefined, undefined, true);
    }
}

export class ContactProperty extends pulumi.dynamic.Resource {
    // @ts-ignore
    public readonly createdContactProperty: pulumi.Output<ContactPropertyProps>;

    constructor(name: string, args: ContactPropertyProps, opts?: pulumi.CustomResourceOptions) {
        const contactProperty = new ContactPropertyProvider();
        const resourceName = "hubspot:contactproperty:" + name
        super(contactProperty, resourceName, { ...args, name, createdContactProperty: undefined }, opts);
    }
}
